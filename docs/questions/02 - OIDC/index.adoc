== Authentication

Authentication is the process of verifying the identity of a user or process. In this part, we will see the different authentication methods and how to implement them.

// TODO : add poc public link

=== Oauth 2.0

OAuth 2.0 is an framework that enables websites or applications to access resources from others web applications, without having to share the user's credentials.

Clearly, it allows a user to grant limited access to their resources on one site, to another site, without having to expose their password.


==== Terminologies

With Oauth 2.0, it's important to understand the different terms. Here is a list of the most important of them :

Protected resource:: The data you want to access. For example, a user's profile information.

Resource server:: The server hosting the protected resource. This is the API you want to access.

Authorization server:: The server that authenticates the user and issues access tokens after getting proper authorization. This is the server that you use to log in to your account.

Client:: The application that wants to access the protected resource. For example, a mobile app or a website.

Resource owner:: The user that owns the protected resource. When the resource owner is a person, it is referred to as an end-user.

Redirect URI:: The URI to which the authorization server will redirect the user after obtaining authorization.

Response type:: The type of the response used to get the authorization code. The authorization code is used to get the access token.

Scope:: The scope of the access request. This is a list of space-delimited, case-sensitive strings, defined by the authorization server.

Consent:: The small box that asks the user if they want to allow the client to access their protected resources.

Client ID:: The client identifier issued to the client during the registration process. This is the public identifier for the client.

Client Secret:: The client secret issued to the client during the registration process. This is the secret known only to the client and the authorization server.

Authorization Code:: The temporary code issued by the authorization server in exchange for the access token request.

Access token:: The token issued by the authorization server. The client uses the access token to access the protected resource.

Access token:: The token issued by the authorization server. The client uses the refresh token to get a new access token.

==== Flow

There is mutliple flow to authenticate a user. Here is the most common ones, and his differences.

.Oauth flows comparaison
image::images/Oauth flows comparaison.png[]

===== Authorization code flow

The authorization code flow is the most secure one. It's the one we will use in this project. Here is a diagram of this flow :

.Authorization code flow
image::images/Authorization code flow.png[]

Because this flow will be used in PolyCode, we will explain it in details. Here are the steps of this flow :

- The user makes a request to the client. In our case, it's a login request.
- The client request the authorization server to get an authorization code.
- The authorization server redirect the user to a authentication and consent page
- The user authenticate and grant the requested scope.
- The authorization server redirect the user to the client, with the authorization code.
- The client send the authorization code, with the client ID and the client secret, to the authorization server.
- The authorization server validate the client ID and the client secret.
- The authorization server send back the access token and the refresh token (and a ID token if the scope contains openid).
- The client can now use the access token to access the protected resource in the resource server.

===== Implicit flow

The implicit flow is the most simple one. In this flow, the authorization server return directly the token. This method is not secure and should not be used in production. Here is a diagram of this flow :

.Implicit flow
image::images/Implicit flow.png[]

===== Hybrid flow

The hybrid flow is the same as authorization code flow, but there is a token server that deliver the token, after authentication by the authorization server. Here is a diagram that explain the request path :

.Hybrid flow
image::images/Hybrid flow.png[]

==== Refresh token

Once the user is authenticated, the authorization server return an access token, valid for a certain amount of time. Once this token expires, the client can ask for a new one, using the refresh token. Here is a diagram of the flow to get a new token :

.Refresh and access token
image::images/Refresh and access token.png[]

==== Scope

A access token permits to access to a protected resource. But, it's not enough to access to all the resources. The authorization server can restrict the access, depending on the scope of the access token.

The score are asked by the client, in the query. Once the user is authenticated, the authorization server ask the user if he want to grant the requested scope, by displaying a consent page. If the user accept, the authorization server return the access token, with the requested scope.

==== SSO
SSO (Single Sign On) is a protocol that allows a user to authenticate once to access multiple applications. With this property, a user logs in with a single ID and password to gain access to a connected system. The user is then signed in to all other systems that are part of the SSO infrastructure. This is in contrast to having to log in separately to each system.

An example of SSO is a student logging in to a university's portal to access email, course registration, and other services.

=== PKCE

PKCE (Proof Key for Code Exchange) is an extension of Oauth 2.0. It's a security feature that prevents an attacker from stealing the authorization code.

==== Terminologies

Here is the terminologies used in PKCE :

Code Verifier:: A huge random string (43 to 128 chars) generated by the client. It's used to generate the code challenge, and is not sent to the authorization server.

Code challenge:: A base 64 encoded string of the code verifier. It's sent to the authorization server.

==== Flow

When the client send the authorization request to the authorization server, he also send the code challenge and the code challenge method (but not the code verifier).

Then, when the client send back the authorization code to the authorization server, he also send the code verifier. The authorization server then hash the code verifier and compare it to the code challenge. If they match, the authorization server send back the access token. Here is a diagram of this flow :

.Authorization code flow with PKCE
image::images/Authorization code flow with PKCE.png[]

=== Oauth 2.1

Oauth 2.1 is not a new protocol, but a reference document. It's a consolidation of best practices in Oauth 2.0. Here is the differences between Oauth 2.0 and Oauth 2.1 :

- PKCE (Proof Key for Code Exchange) is mandatory.
- Redirect URI must be compared using exact string matching.
- Implicit flow is not allowed.
- Resource owner password credentials grant flow is not allowed (because with this flow, the client can access to the user's password).
- Bearer token usage requires the use of the HTTP Authorization header field instead of the query parameter.
- Refresh tokens must be bound to the client that requested them, or be one-time use.

=== OpenID Connect

OpenID Connect (OIDC) is an authentication layer on top of Oauth 2.0. It's a protocol that allows clients to verify the identity of the end-user based on the authentication performed by an authorization server, as well as to obtain basic profile information about the end-user in an interoperable and REST-like manner.

==== OIDC scopes

There is multiple scopes in OIDC. Let's see the most common ones :

.OIDC scopes
image::images/OIDC scopes.png[]

=== JWT

JWT (JSON Web Token) is an open standard that define a compact and URL-safe way to represent claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object. He have a header, a payload and a signature. He also have a expiration date.

The JWT is used for the authentication in OpenID Connect. His integrity is verified by the signature, then no one can modify the data.

==== Anatomy

Here is an explaination of the JWT parts :

.JWT decomposition
image::images/JWT decomposition.png[]

==== Claims

The payload of a JWT contains claims. Claims are statements about an entity (typically, a user) and additional metadata.

There are three types of claims :

- Registered claims: These are a set of predefined claims which are not mandatory but recommended. Some of them are : iss (issuer), sub (subject), aud (audience), exp (expiration time), nbf (not before), iat (issued at), and jti (JWT ID).

- Public claims: These can be defined at will by those using JWTs. This can be used to share information between parties that agree on using the same claim names.

- Private claims:: These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims.

Here is an payload of an basic ID token used in OpenID Connect, with the definition of each claims :

.ID token payload
image::images/ID token payload.png[]

==== Endpoints

Here is the endpoints defines in OIDC :

.OIDC endpoints
image::images/OIDC endpoints.png[]

=== Tools

==== KeyCloak

===== Migration

==== Okta

==== Auth0

==== FusionAuth

==== AWS Cognito