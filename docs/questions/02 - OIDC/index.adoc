== Authentication

Authentication is the process of verifying the identity of a user or process. In this part, we will see the different authentication methods and how to implement them.

// TODO : add poc public link

=== Oauth 2.0

OAuth 2.0 is an framework that enables websites or applications to access resources from others web applications, without having to share the user's credentials.

Clearly, it allows a user to grant limited access to their resources on one site, to another site, without having to expose their password.


==== Terminologies

With Oauth 2.0, it's important to understand the different terms. Here is a list of the most important of them :

Protected resource:: The data you want to access. For example, a user's profile information.

Resource server:: The server hosting the protected resource. This is the API you want to access.

Authorization server:: The server that authenticates the user and issues access tokens after getting proper authorization. This is the server that you use to log in to your account.

Client:: The application that wants to access the protected resource. For example, a mobile app or a website.

Resource owner:: The user that owns the protected resource. When the resource owner is a person, it is referred to as an end-user.

Redirect URI:: The URI to which the authorization server will redirect the user after obtaining authorization.

Response type:: The type of the response used to get the authorization code. The authorization code is used to get the access token.

Scope:: The scope of the access request. This is a list of space-delimited, case-sensitive strings, defined by the authorization server.

Consent:: The small box that asks the user if they want to allow the client to access their protected resources.

Client ID:: The client identifier issued to the client during the registration process. This is the public identifier for the client.

Client Secret:: The client secret issued to the client during the registration process. This is the secret known only to the client and the authorization server.

Authorization Code:: The temporary code issued by the authorization server in exchange for the access token request.

Access token:: The token issued by the authorization server. The client uses the access token to access the protected resource.

Access token:: The token issued by the authorization server. The client uses the refresh token to get a new access token.

==== Flow

There is mutliple flow to authenticate a user. Here is the most common ones, and his differences.

.Oauth flows comparaison
image::images/Oauth flows comparaison.png[]

===== Authorization code flow

The authorization code flow is the most secure one. It's the one we will use in this project. Here is a diagram of this flow :

.Authorization code flow
image::images/Authorization code flow.png[]

===== Implicit flow

The implicit flow is the most simple one. In this flow, the authorization server return directly the token. This method is not secure and should not be used in production. Here is a diagram of this flow :

.Implicit flow
image::images/Implicit flow.png[]

===== Hybrid flow

The hybrid flow is the same as authorization code flow, but there is a token server that deliver the token, after authentication by the authorization server. Here is a diagram that explain the request path :

.Hybrid flow
image::images/Hybrid flow.png[]

==== Refresh token

Once the user is authenticated, the authorization server return an access token, valid for a certain amount of time. Once this token expires, the client can ask for a new one, using the refresh token. Here is a diagram of the flow to get a new token :

.Refresh and access token
image::images/Refresh and access token.png[]

==== Scope

A access token permits to access to a protected resource. But, it's not enough to access to all the resources. The authorization server can restrict the access, depending on the scope of the access token.

The score are asked by the client, in the query. Once the user is authenticated, the authorization server ask the user if he want to grant the requested scope, by displaying a consent page. If the user accept, the authorization server return the access token, with the requested scope.

==== SSO
SSO (Single Sign On) is a protocol that allows a user to authenticate once to access multiple applications. With this property, a user logs in with a single ID and password to gain access to a connected system. The user is then signed in to all other systems that are part of the SSO infrastructure. This is in contrast to having to log in separately to each system.

An example of SSO is a student logging in to a university's portal to access email, course registration, and other services.

=== PKCE

PKCE (Proof Key for Code Exchange) is an extension of Oauth 2.0. It's a security feature that prevents an attacker from stealing the authorization code.

==== Terminologies

Here is the terminologies used in PKCE :

Code Verifier:: A huge random string (43 to 128 chars) generated by the client. It's used to generate the code challenge, and is not sent to the authorization server.

Code challenge:: A base 64 encoded string of the code verifier. It's sent to the authorization server.

==== Flow

When the client send the authorization request to the authorization server, he also send the code challenge and the code challenge method (but not the code verifier).

Then, when the client send back the authorization code to the authorization server, he also send the code verifier. The authorization server then hash the code verifier and compare it to the code challenge. If they match, the authorization server send back the access token. Here is a diagram of this flow :

.Authorization code flow with PKCE
image::images/Authorization code flow with PKCE.png[]

=== Oauth 2.1

Oauth 2.1 is not a new protocol, but a reference document. It's a consolidation of best practices in Oauth 2.0. Here is the differences between Oauth 2.0 and Oauth 2.1 :

- PKCE (Proof Key for Code Exchange) is mandatory.
- Redirect URI must be compared using exact string matching.
- Implicit flow is not allowed.
- Resource owner password credentials grant flow is not allowed (because with this flow, the client can access to the user's password).
- Bearer token usage requires the use of the HTTP Authorization header field instead of the query parameter.
- Refresh tokens must be bound to the client that requested them, or be one-time use.

=== OpenID Connect (OIDC)

https://www.ibm.com/docs/en/cics-ts/6.1?topic=cics-openid-connect[Source IBM (smallest)] +
https://connect2id.com/learn/openid-connect[Source]

Adding to Oauth2, this provides more information about the resource owner. Itâ€™s like JWT (Json Web Token). +
Use to make SSO (Single Sign On) = One login to use multiple others APIs = Give to user better experience because prevent for massive account creation

=== SSO

Single sign-on (SSO) is an authentication method that enables users to securely authenticate with multiple applications and websites by using just one set of credentials. // TODO perhaps to develop

=== JWT

https://www.ibm.com/docs/en/cics-ts/6.1?topic=cics-json-web-token-jwt[Source IBM]

==== Anatomy

.JWT decomposition
image::images/JWT decomposition.png[]

==== Claims

https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims[Standards claims]

image::images/image7.png[]

image::images/image8.png[]

Ask specific claim

image::images/image9.png[]

==== Flow

image::images/image10.png[]

1. The user makes a request to the client application.
2. The client application redirects the request to the OpenID Connect Provider (OP) for authorization.
3. The OP sends an authentication and authorization request to the user.
4. The user authenticates and authorizes the client application to access the resource.
5. The OP sends a grant code to the client application.
6. The client application sends a request to the OP to exchange the grant code for an ID token (in the form of a JWT), an access token, and a refresh token.
7. The OP sends the ID token (JWT), access token, and refresh token to the client application.
8. The client application makes the request to the resource server with the JWT, which is used to authenticate the user and to authorize access to the resource.
9. The response is sent from the resource server to the client application.
10. The response is sent from the client application to the user.

==== Endpoints

https://connect2id.com/learn/openid-connect#endpoints[endpoints]

image::images/image11.png[]

=== Tools

==== KeyCloak

===== Migration

==== Okta

==== Auth0

==== FusionAuth

==== AWS Cognito